---
{"dg-publish":true,"permalink":"/my-project/igil-device-firmware/","dgPassFrontmatter":true,"created":"2023-12-13T17:50:08.560+09:00","updated":"2023-12-14T17:17:57.857+09:00"}
---


# 개발환경
## [[MyResource/Embedded/RpiPico/MicroPython\|MicroPython]]


# 요구사항
## 자이로센서
### BMI160
## Bluetooth BLE
### ubluetooth.BLE


## 배터리 잔량
### MAX17043
## LED 제어
### 전면 LED
### 하단부 LED
### LED 인디케이터


# PROBLEM
## MCP3202 SPI 통신 문제
### 문제 코드
    spi_csn.low()
    
    data_out = bytearray([0x01])
    dataIn = bytearray(1)
    spi.write(data_out)

    data_out[0] = 0b10100000
    spi.write_readinto(data_out, dataIn)
    result = dataIn[0] & 0x0F

    spi.write_readinto(bytearray([0x00]), dataIn)
    result = result << 8
    result = result | dataIn[0]

    spi_csn.high()

### 코드 풀이
- spi.write :  buf에 포함된 byte를 기록하고 none을 반환
- write_readinto : read_buf로 읽는 동안 write_buf에서 바이트를 기록, none을 반환합니다.
- 0b00000001 쓰기 : start bit
- 0b10100000 쓰며 읽기 : single ended mode '0' channel + MSBF high + Null Bit + B11 ~ B8
- result = B11 ~ B8
- 0b00000000 쓰며 읽기 : dataIn = B7 ~ B0
- result << 8
- result | dataIn[0] == B11 ~ B0
- result = B11 ~ B0

### 문제 상황
- result의 값이 4095(0x0fff)로 고정

### MCP3202 DATASHEET

MCP3202와의 통신은 표준 SPI 호환 직렬 인터페이스를 사용하여 수행된다. 
장치와 통신을 시작하는 것은 CS 라인을 낮게 함으로써 수행된다. 
그림 5-1을 참조하라. 장치가 CS 핀을 낮게 설정한 상태에서 파워업되었다면, 통신을 시작하기 위해 높게 설정되었다가 다시 낮게 설정되어야 한다. 
CS 로우 및 DIN 하이로 수신된 첫 번째 클럭은 시작 비트를 구성할 것이다. 
SGL/DIFF 비트와 ODD/SIGN 비트는 시작 비트를 따르고 입력 채널 구성-구성을 선택하는 데 사용된다. 
SGL/DIFF는 싱글 엔디드 모드 또는 PSUEDO 차동 모드를 선택하는 데 사용된다.
ODD/SIGN 비트는 싱글 엔디드 모드에서 사용되는 채널을 선택하고 의사 차동 모드에서 극성을 결정하는 데 사용된다. 
ODD/SIGN 비트에 이어 MSBF 비트가 로 전송되어 장치의 LSB 첫 번째 포맷을 활성화하는 데 사용된다. 
MSBF 비트가 높으면 데이터는 MSB 첫 번째 포맷의 장치로부터 오고 CS 로우로 더 이상의 클럭은 장치가 제로를 출력하게 할 것이다. 
MSBF 비트가 낮으면 장치는 워드가 MSB 첫 번째 포맷으로 전송된 후 변환된 워드 LSB를 먼저 출력할 것이다. 
그림 5-2를 참조하라. 

표 5-1은 MCP3202에 대한 구성 비트들을 보여준다. 
장치는 시작 비트가 수신된 후, 클럭의 두 번째 상승 에지에서 아날로그 입력의 샘플링을 시작할 것이다. 
샘플 주기는 시작 비트를 따라 세 번째 클럭의 하강 에지에서 종료될 것이다. 
MSBF 비트에 대한 클럭의 하강 에지에서, 장치는 낮은 널 비트를 출력할 것이다. 
다음 연속적인 12개의 클럭은 그림 5-1과 같이 MSB와의 변환 결과를 먼저 출력할 것이다. 
데이터는 항상 클럭의 하강 에지의 장치에서 출력된다. 
만약 12개의 데이터 비트가 모두 전송되었고 CS가 낮게 유지된 상태에서 장치가 클럭을 계속 수신한다면 (and MSBF = 1), 장치는 LSB와 같이 첫 번째 변환 결과를 출력할 것이다. 
CS가 낮은 상태에서(LSB 첫 번째 데이터가 전송된 후) 더 많은 클럭이 장치에 제공되면 장치는 무제한으로 0을 클록아웃합니다. 
필요한 경우 CS를 로우로 가져와 시작 비트 이전에 DIN 라인의 선행 0을 클록킹할 수 있습니다. 
이는 한 번에 8비트를 전송해야 하는 마이크로컨트롤러 기반 SPI 포트를 다룰 때 종종 수행됩니다. 
하드웨어 SPI 포트와 함께 MCP3202 장치를 사용하는 방법에 대한 자세한 내용은 섹션 6.1을 참조하십시오

![Pasted image 20231004162757.png](/img/user/AttachedFile/Pasted%20image%2020231004162757.png)
- FIGURE 5-1

![Pasted image 20231004162902.png](/img/user/AttachedFile/Pasted%20image%2020231004162902.png)
- FIGURE 5-2

대부분의 마이크로컨트롤러 SPI 포트에서는 8비트의 그룹을 전송해야 합니다. 
또한 마이크로컨트롤러 SPI 포트는 하강 에지의 데이터를 클록아웃하고 상승 에지의 데이터를 래치하도록 구성해야 합니다. 
통신 루틴을 어떻게 사용하느냐에 따라 통신에 필요한 클록의 수는 8의 배수가 되지 않을 가능성이 매우 높습니다. 
따라서 MCU에서 실제로 필요한 것보다 더 많은 클록을 전송해야 할 수도 있습니다. 
이는 일반적으로 시작 비트 전에 '선행 0'을 전송함으로써 수행되며, 이는 장치에서 무시합니다. 

예를 들어 그림 6-1과 그림 6-2는 하드웨어 SPI 포트를 통해 MCP3202를 MCU와 인터페이싱하는 방법을 보여줍니다. 
그림 6-1은 SPI Mode0.0의 동작을 보여주는데, 이는 MCU의 SCLK가 '낮음' 상태에서 공회전해야 하는 반면, 그림 6-2는 SPI Mode1의 경우와 유사하게 클럭이 '높음' 상태에서 공회전해야 합니다. 
그림 6-1과 같이 A/D Converter로 전송된 첫 번째 바이트는 시작 비트 전에 7개의 선행 0을 포함합니다. 
선행 0을 이렇게 배열하면 MCU에서 쉽게 조작할 수 있는 위치에 12비트의 출력이 떨어집니다. 
MSB는 클록 번호 12의 하강 에지에서 A/D Converter에서 클록아웃됩니다. 
두 번째 8개의 클록이 장치로 전송된 후 MCU 
수신 버퍼는 알 수 없는 3비트(null 비트가 클록아웃될 때까지 출력이 고임피던스에 있음), null 비트 및 변환의 최상위 4비트를 포함합니다.
세 번째 바이트가 장치로 전송된 후 수신 레지스터에는 변환 결과 중 가장 낮은 순서의 비트가 포함됩니다. 
이 방법을 사용하면 변환 데이터를 더 쉽게 조작할 수 있습니다

![Pasted image 20231004162952.png](/img/user/AttachedFile/Pasted%20image%2020231004162952.png)
- FIGURE 6-1
![Pasted image 20231004163007.png](/img/user/AttachedFile/Pasted%20image%2020231004163007.png)
- FIGURE 6-2
-------------------------------------------------
MCP3202가 샘플 주기를 시작하면 전하가 샘플 커패시터에 저장됩니다. 샘플 주기가 완료되면 장치는 수신되는 각 클럭마다 1비트씩 변환합니다. 사용자는 클럭 속도가 느려지면 변환이 진행되는 동안 전하가 샘플 캡에서 블리딩될 수 있습니다. 85°C(최악의 경우 조건)에서 부품은 샘플 주기가 끝난 후 최소 1.2ms 동안 샘플 커패시터에 적절한 전하를 유지합니다. 이는 샘플 주기가 끝날 때부터 모든 12개 데이터 비트가 클럭아웃된 시간 사이의 시간이 1.2ms(유효 클럭 주파수 10kHz)를 초과해서는 안 된다는 것을 의미합니다. 이 기준을 충족하지 못하면 정격 사양 밖의 변환에 선형-it 오류가 발생할 수 있습니다. 전체 변환 주기 동안 모든 타이밍 사양이 충족되는 한 A/D 컨버터는 일정한 클럭 속도나 듀티 사이클을 필요로 하지 않습니다

A/D 컨버터의 신호 소스가 로우 임피던스 소스가 아닌 경우 버퍼링해야 하거나 정확하지 않은 변환 결과가 발생할 수 있습니다. 또한 변환 결과로 다시 앨리어싱될 수 있는 신호를 제거하기 위해 필터를 사용하는 것이 좋습니다. 아래 그림 6-3에는 MCP3202의 아날로그 입력을 구동하기 위해 op amplifier가 사용됩니다. 이 앰프는 컨버터 입력을 위한 로우 임피던스 출력과 원하지 않는 고주파 노이즈를 제거하는 로우 패스 필터를 제공합니다. 로우 패스(Anti-aliasing) 필터는 마이크로칩의 인터랙티브 FilterLab™ 소프트웨어를 사용하여 설계할 수 있습니다. FilterLab은 캐패시터 및 저항 값뿐만 아니라 응용 프로그램에 필요한 극의 개수도 계산합니다. 신호 필터링에 대한 자세한 내용은 애플리케이션 노트 AN699 "Anti-Aliasing AnalogFilters for Data Acquisition Systems"를 참조하십시오

아날로그 부품과 함께 사용할 수 있도록 인쇄회로기판을 배치할 때에는 가능한 한 소음을 줄일 수 있도록 주의해야 합니다. 바이패스 커패시터는 항상 이 장치와 함께 사용되어야 하며 장치 핀에 최대한 가깝게 배치되어야 합니다. 0.1μF의 바이패스 커패시터 값이 권장됩니다.디지털 및 아날로그 트레이스는 보드에서 가능한 한 분리되어야 하며 장치 또는 바이패스 커패시터 아래에서 흔적이 흐르지 않아야 합니다. 아날로그 트레이스에서 가능한 한 고주파 신호(클럭 라인 등)로 트레이스를 유지하기 위해 추가 예방 조치를 취해야 합니다. 보드의 모든 장치에서 접지 전위를 동일하게 유지하기 위해서는 아날로그 접지면을 사용하는 것이 권장됩니다. "별" 구성의 장치에 VDD 연결을 제공하면 전류 리턴 경로 및 관련 오류를 제거하여 노이즈를 줄일 수도 있습니다. 그림 6-4를 참조하십시오. A/D 컨버터를 사용할 때 레이아웃 팁에 대한 자세한 내용은 AN688 "12비트 A/D 컨버터 응용 프로그램을 위한 레이아웃 팁"(DS00688)을 참조하십시오
